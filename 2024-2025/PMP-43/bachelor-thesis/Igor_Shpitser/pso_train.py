import argparse
import json
import os
from pathlib import Path
from concurrent.futures import ProcessPoolExecutor, as_completed

import numpy as np

from material import Material
from shapeFunction import LinearQuadrilateralShapeFunction
from pso_algorithm import PSO, fitness_function, get_K_ref


def is_convex_quad(pts: list[list[float]]) -> bool:
    def cross_z(a, b, c):
        bax, bay = b[0] - a[0], b[1] - a[1]
        cbx, cby = c[0] - b[0], c[1] - b[1]
        return bax * cby - bay * cbx

    signs = []
    for i in range(4):
        a, b, c = pts[i], pts[(i+1) % 4], pts[(i+2) % 4]
        cz = cross_z(a, b, c)
        if abs(cz) > 1e-8:
            signs.append(cz)
    return all(s > 0 for s in signs) or all(s < 0 for s in signs)


def optimize_on_quad(quad_coords, mat, shape_func, args):
    coords = np.array(quad_coords)

    K_ref = get_K_ref(coords, mat, shape_func=shape_func)

    fit = lambda pos: fitness_function(pos, coords, mat, K_ref, shape_func)

    DIM = 3 * args.ng * args.ng
    lo = np.concatenate([
        np.full(args.ng**2, -1.0),
        np.full(args.ng**2, -1.0),
        np.full(args.ng**2,  0.0)
    ])
    hi = np.concatenate([
        np.full(args.ng**2, 1.0),
        np.full(args.ng**2, 1.0),
        np.full(args.ng**2, 6.0)
    ])

    pso = PSO(
        fitness_func  = fit,
        n_particles   = args.npart,
        dim           = DIM,
        lo            = lo,
        hi            = hi,
        tol           = 1e-6,
        target_fitness= args.fitthr,
        maximize      = True
    )

    print(f"▶ Running PSO on one quadrilateral…")
    best_pos, best_fit = pso.optimize()
    print(f"✓ Done: best fitness = {best_fit:.6g}")


    return {
        "features": quad_coords[2] + quad_coords[3],

        "labels":  best_pos.tolist(),

        "fitness": best_fit
    }
    # ──────────────────────────────────────────


def main():
    parser = argparse.ArgumentParser(description="Train PSO on random convex quads")
    parser.add_argument("--mu",     type=float, default=0.7,   help="Shear modulus μ")
    parser.add_argument("--nu",     type=float, default=0.30,  help="Poisson ratio ν")
    parser.add_argument("--ng",     type=int,   default=2,     help="Gauss points per axis (nG)")
    parser.add_argument("--npart",  type=int,   default=120,   help="Particles per PSO run")
    parser.add_argument("--fitthr", type=float, default=4.0,   help="Fitness threshold for early stop")
    parser.add_argument("--nquad",  type=int,   default=1000, help="Number of random quadrilaterals")
    parser.add_argument("--outfile",type=Path,  default=Path("quadrature_data.py"),
                        help="Output *.py file with results")
    args = parser.parse_args()

    E_calc    = 2.0 * args.mu * (1.0 + args.nu)
    print(f"▶ Using E = {E_calc:.6g}  (μ={args.mu}, ν={args.nu})")
    mat        = Material("Generic", E=E_calc, nu=args.nu)
    shape_func = LinearQuadrilateralShapeFunction()

    rng = np.random.default_rng()
    quads = []
    while len(quads) < args.nquad:
        bl = [-1.0, -1.0]
        br = [ 1.0, -1.0]
        ul = [rng.uniform(0.5,3.0), rng.uniform(0.5,3.0)]
        ur = [rng.uniform(0.5,3.0), rng.uniform(0.5,3.0)]
        quad = [bl, br, ur, ul]
        if is_convex_quad(quad):
            quads.append(quad)
    print(f"▶ Generated {len(quads)} convex quads.")

    workers = os.cpu_count() or 1
    print(f"▶ Running PSO on {len(quads)} quads with {workers} workers…")
    results = []
    with ProcessPoolExecutor(max_workers=workers) as exe:
        futures = {exe.submit(optimize_on_quad, q, mat, shape_func, args): q for q in quads}
        for fut in as_completed(futures):
            res = fut.result()
            print(f"  → fitness={res['fitness']:.4g}")
            results.append(res)

    with open(args.outfile, "w", encoding="utf-8") as f:
        f.write("# Auto-generated by pso_train.py\n")
        f.write("data = ")
        json.dump(results, f, indent=2)
        f.write("\n")

    print(f"✅ Saved {len(results)} entries to {args.outfile}")


if __name__ == "__main__":
    main()
